diff --git a/fontforge/charview.c b/fontforge/charview.c
index afa6e47..cf8bb3a 100644
--- a/fontforge/charview.c
+++ b/fontforge/charview.c
@@ -107,6 +107,11 @@ struct cvshows CVShows = {
 	1,		/* Check for self-intersections in the element view */
 	1		/* In tt debugging, mark changed rasters differently */
 };
+
+#define CID_Base	      1001
+#define CID_getValueFromUser  CID_Base + 1
+
+
 static Color pointcol = 0xff0000;
 static Color firstpointcol = 0x707000;
 static Color selectedpointcol = 0xc8c800;
@@ -6767,14 +6938,229 @@ static void CVUnlinkRef(GWindow gw,struct gmenuitem *mi,GEvent *e) {
     _CVUnlinkRef(cv);
 }
 
-static void CVRemoveUndoes(GWindow gw,struct gmenuitem *mi,GEvent *e) {
-    CharView *cv = (CharView *) GDrawGetUserData(gw);
+typedef struct getValueDialogData
+{
+    int done;
+    int cancelled;
+    CharView *cv;
+    GWindow gw;
+    char* ret;
+    GTextInfo label;
+} GetValueDialogData;
+
+static int getValueDialogData_e_h(GWindow gw, GEvent *event) {
+    if ( event->type==et_close ) {
+	GetValueDialogData *hd = GDrawGetUserData(gw);
+	hd->done = true;
+    } else if ( event->type == et_char ) {
+return( false );
+    } else if ( event->type == et_map ) {
+	/* Above palettes */
+	GDrawRaise(gw);
+    }
+return( true );
+}
+
+static int getValueFromUser_OK(GGadget *g, GEvent *e)
+{
+    if ( e->type==et_controlevent && e->u.control.subtype == et_buttonactivate ) {
+        GetValueDialogData *hd = GDrawGetUserData(GGadgetGetWindow(g));
+        strcpy( hd->ret, hd->label.text );
+        strcpy( hd->ret, GGadgetGetTitle8(GWidgetGetControl(hd->gw,CID_getValueFromUser)));
+        hd->done = true;
+    }
+    return( true );
+}
+
+static int getValueFromUser_Cancel(GGadget *g, GEvent *e) {
+    if ( e->type==et_controlevent && e->u.control.subtype == et_buttonactivate ) {
+        GetValueDialogData *hd = GDrawGetUserData(GGadgetGetWindow(g));
+        hd->cancelled = true;
+        hd->done = true;
+    }
+    return( true );
+}
+
+static char* getValueFromUser( CharView *cv, const char* windowTitle, const char* msg, const char* defaultValue )
+{
+    const int retsz = 4096;
+    static char ret[4097];
+    static GetValueDialogData DATA;
+    GRect pos;
+    GWindow gw;
+    GWindowAttrs wattrs;
+    GGadgetCreateData gcd[9], *harray1[4], *harray2[9], *barray[7], *varray[5][2], boxes[5];
+    GTextInfo label[9];
+    char buffer[200]; unichar_t ubuf[200];
+
+    DATA.cancelled = false;
+    DATA.done = false;
+    DATA.cv = cv;
+    DATA.ret = ret;
+    ret[0] = '\0';
+    
+    if ( DATA.gw==NULL ) {
+	memset(&wattrs,0,sizeof(wattrs));
+	wattrs.mask = wam_events|wam_cursor|wam_utf8_wtitle|wam_undercursor|wam_isdlg|wam_restrict;
+	wattrs.event_masks = ~(1<<et_charup);
+	wattrs.restrict_input_to_me = 1;
+	wattrs.undercursor = 1;
+	wattrs.cursor = ct_pointer;
+	wattrs.utf8_window_title = windowTitle;
+	wattrs.is_dlg = true;
+	pos.x = pos.y = 0;
+	pos.width = GGadgetScale(GDrawPointsToPixels(NULL,170));
+	pos.height = GDrawPointsToPixels(NULL,90);
+	DATA.gw = gw = GDrawCreateTopWindow(NULL,&pos,getValueDialogData_e_h,&DATA,&wattrs);
+
+	memset(&label,0,sizeof(label));
+	memset(&gcd,  0,sizeof(gcd));
+	memset(&boxes,0,sizeof(boxes));
+
+	label[0].text = (unichar_t *) msg;
+	label[0].text_is_1byte = true;
+	label[0].text_in_resource = true;
+	gcd[0].gd.label = &label[0];
+	gcd[0].gd.pos.x = 5;
+	gcd[0].gd.pos.y = 5;
+	gcd[0].gd.flags = gg_enabled|gg_visible;
+	gcd[0].creator = GLabelCreate;
+	harray1[0] = GCD_Glue;
+	harray1[1] = &gcd[0];
+	harray1[2] = 0;
+            
+	label[1].text = (unichar_t *) defaultValue;
+	label[1].text_is_1byte = true;
+	DATA.label = label[1];
+	gcd[1].gd.label = &label[1];
+	gcd[1].gd.pos.x = 5;
+	gcd[1].gd.pos.y = 17+5;
+	gcd[1].gd.pos.width = 40;
+	gcd[1].gd.flags = gg_enabled|gg_visible;
+	gcd[1].gd.cid = CID_getValueFromUser;
+	gcd[1].creator = GTextFieldCreate;
+	harray2[0] = &gcd[1];
+	harray2[1] = 0;
+            
+	int idx = 2;
+	gcd[idx].gd.pos.x = 20-3;
+	gcd[idx].gd.pos.y = 17+37;
+	gcd[idx].gd.pos.width = -1;
+	gcd[idx].gd.pos.height = 0;
+	gcd[idx].gd.flags = gg_visible | gg_enabled | gg_but_default;
+	label[idx].text = (unichar_t *) _("_OK");
+	label[idx].text_is_1byte = true;
+	label[idx].text_in_resource = true;
+	gcd[idx].gd.mnemonic = 'O';
+	gcd[idx].gd.label = &label[idx];
+	gcd[idx].gd.handle_controlevent = getValueFromUser_OK;
+	gcd[idx].creator = GButtonCreate;
+	barray[0] = GCD_Glue;
+	barray[1] = &gcd[idx];
+	barray[2] = GCD_Glue;
+	
+	++idx;
+	gcd[idx].gd.pos.x = -20;
+	gcd[idx].gd.pos.y = 17+37+3;
+	gcd[idx].gd.pos.width = -1;
+	gcd[idx].gd.pos.height = 0;
+	gcd[idx].gd.flags = gg_visible | gg_enabled | gg_but_cancel;
+	label[idx].text = (unichar_t *) _("_Cancel");
+	label[idx].text_is_1byte = true;
+	label[idx].text_in_resource = true;
+	gcd[idx].gd.label = &label[idx];
+	gcd[idx].gd.mnemonic = 'C';
+	gcd[idx].gd.handle_controlevent = getValueFromUser_Cancel;
+	gcd[idx].creator = GButtonCreate;
+	barray[3] = GCD_Glue;
+	barray[4] = &gcd[idx];
+	barray[5] = GCD_Glue;
+	barray[6] = NULL;
+
+	gcd[7].gd.pos.x = 5;
+	gcd[7].gd.pos.y = 17+31;
+	gcd[7].gd.pos.width = 170-10;
+	gcd[7].gd.flags = gg_enabled|gg_visible;
+	gcd[7].creator = GLineCreate;
+
+	boxes[2].gd.flags = gg_enabled|gg_visible;
+	boxes[2].gd.u.boxelements = harray1;
+	boxes[2].creator = GHBoxCreate;
+
+	boxes[3].gd.flags = gg_enabled|gg_visible;
+	boxes[3].gd.u.boxelements = harray2;
+	boxes[3].creator = GHBoxCreate;
+
+	boxes[4].gd.flags = gg_enabled|gg_visible;
+	boxes[4].gd.u.boxelements = barray;
+	boxes[4].creator = GHBoxCreate;
+
+	varray[0][0] = &boxes[2]; varray[0][1] = NULL;
+	varray[1][0] = &boxes[3]; varray[1][1] = NULL;
+	varray[2][0] = &gcd[7];   varray[2][1] = NULL;
+	varray[3][0] = &boxes[4]; varray[3][1] = NULL;
+	varray[4][0] = NULL;
+
+	boxes[0].gd.pos.x = boxes[0].gd.pos.y = 2;
+	boxes[0].gd.flags = gg_enabled|gg_visible;
+	boxes[0].gd.u.boxelements = varray[0];
+	boxes[0].creator = GHVGroupCreate;
+	
+	GGadgetsCreate(gw,boxes);
+	GHVBoxSetExpandableCol(boxes[2].ret,gb_expandglue);
+	GHVBoxSetExpandableCol(boxes[3].ret,gb_expandglue);
+	GHVBoxSetExpandableCol(boxes[4].ret,gb_expandgluesame);
+	GHVBoxFitWindow(boxes[0].ret);
+    } else {
+	gw = DATA.gw;
+	snprintf( ret, retsz, "%s", defaultValue );
+	GGadgetSetTitle8(GWidgetGetControl(gw,CID_getValueFromUser),ret);
+	GDrawSetTransientFor(gw,(GWindow) -1);
+    }
+
+    GWidgetIndicateFocusGadget(GWidgetGetControl(gw,CID_getValueFromUser));
+    GTextFieldSelect(GWidgetGetControl(gw,CID_getValueFromUser),0,-1);
+
+    GWidgetHidePalettes();
+    GDrawSetVisible(gw,true);
+    while ( !DATA.done )
+	GDrawProcessOneEvent(NULL);
+    GDrawSetVisible(gw,false);
 
-    UndoesFree(cv->b.layerheads[cv->b.drawmode]->undoes);
-    UndoesFree(cv->b.layerheads[cv->b.drawmode]->redoes);
-    cv->b.layerheads[cv->b.drawmode]->undoes = cv->b.layerheads[cv->b.drawmode]->redoes = NULL;
+    if( DATA.cancelled )
+        return 0;
+    return ret;
 }
 
+static int toint( char* v )
+{
+    if( !v )
+        return 0;
+    return atoi(v);
+}
+static char* tostr( int v )
+{
+    const int bufsz = 100;
+    static char buf[101];
+    snprintf(buf,bufsz,"%ld",v);
+    return buf;
+}
+
+
+static void CVRemoveUndoes(GWindow gw,struct gmenuitem *mi,GEvent *e)
+{
+    CharView *cv = (CharView *) GDrawGetUserData(gw);
+    static int lastValue = 10;
+    int v = toint(getValueFromUser( cv,
+				    "Trimming Undo Information",
+				    "How many most-recent Undos should be kept?",
+				    tostr(lastValue)));
+    lastValue = v;
+    UndoesFreeButRetainFirstN(&cv->b.layerheads[cv->b.drawmode]->undoes,v);
+    UndoesFreeButRetainFirstN(&cv->b.layerheads[cv->b.drawmode]->redoes,v);
+}
+
+
 /* We can only paste if there's something in the copy buffer */
 /* we can only copy if there's something selected to copy */
 /* figure out what things are possible from the edit menu before the user */
@@ -9422,7 +9808,7 @@ static GMenuItem2 edlist[] = {
     { { NULL, NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 1, 0, 0, 0, 1, 0, 0, }},
     { { (unichar_t *) N_("U_nlink Reference"), (GImage *) "editunlink.png", COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 1, 0, 0, 0, 0, 1, 1, 0, 'U' }, H_("Unlink Reference|Ctl+U"), NULL, NULL, CVUnlinkRef, MID_UnlinkRef },
     { { NULL, NULL, COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 1, 0, 0, 0, 1, 0, 0, }},
-    { { (unichar_t *) N_("Remo_ve Undoes"), (GImage *) "menuempty.png", COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 1, 0, 0, 0, 0, 1, 1, 0, 'e' }, H_("Remove Undoes|No Shortcut"), NULL, NULL, CVRemoveUndoes, MID_RemoveUndoes },
+    { { (unichar_t *) N_("Remo_ve Undoes..."), (GImage *) "menuempty.png", COLOR_DEFAULT, COLOR_DEFAULT, NULL, NULL, 0, 1, 0, 0, 0, 0, 1, 1, 0, 'e' }, H_("Remove Undoes|No Shortcut"), NULL, NULL, CVRemoveUndoes, MID_RemoveUndoes },
     { NULL }
 };
 
diff --git a/fontforge/cvundoes.c b/fontforge/cvundoes.c
index fd5623a..339b5d8 100644
--- a/fontforge/cvundoes.c
+++ b/fontforge/cvundoes.c
@@ -29,6 +29,8 @@
 #include <math.h>
 #include <ustring.h>
 #include <utype.h>
+#include <execinfo.h>
+#include <stdio.h>
 
 extern char *coord_sep;
 
@@ -37,6 +39,21 @@ int copymetadata = 0;
 int copyttfinstr = 0;
 int export_clipboard = 1;
 
+void BackTraceFD( int fd ) {
+    const int arraysz = 500;
+    void* array[arraysz];
+    size_t size;
+    
+    size = backtrace( array, arraysz ); 
+    backtrace_symbols_fd( array, size, fd );
+}
+
+void BackTrace( const char* msg ) {
+    fprintf( stderr, msg );
+    BackTraceFD( 2 );
+}
+
+
 /* ********************************* Undoes ********************************* */
 
 int maxundoes = 12;		/* -1 is infinite */
@@ -380,7 +397,7 @@ return;
     }
 }
 
-static void *UHintCopy(SplineChar *sc,int docopy) {
+void *UHintCopy(SplineChar *sc,int docopy) {
     StemInfo *h = sc->hstem, *v = sc->vstem, *last=NULL;
     DStemInfo *d = sc->dstem;
     void *ret = NULL;
@@ -417,7 +434,7 @@ static void *UHintCopy(SplineChar *sc,int docopy) {
 return(ret);
 }
 
-static void ExtractHints(SplineChar *sc,void *hints,int docopy) {
+void ExtractHints(SplineChar *sc,void *hints,int docopy) {
     StemInfo *h = NULL, *v = NULL, *p;
     DStemInfo *d = NULL;
     StemInfo *pv = NULL, *pd = NULL;
@@ -458,6 +475,34 @@ static void ExtractHints(SplineChar *sc,void *hints,int docopy) {
     sc->vconflicts = StemInfoAnyOverlaps(v);
 }
 
+void UndoesFreeButRetainFirstN( Undoes** undopp, int retainAmount )
+{
+    if( !undopp || !*undopp )
+        return;
+    Undoes* undo = *undopp;
+    // wipe them all will change the list header pointer too
+    if( !retainAmount ) {
+        UndoesFree( undo );
+        *undopp = 0;
+        return;
+    }
+    
+    Undoes* undoprev = undo;
+    for( ; retainAmount > 0 && undo ; retainAmount-- )
+    {
+        undoprev = undo;
+        undo = undo->next;
+    }
+    // not enough items to need to do a trim.
+    if( retainAmount > 0 )
+        return;
+    
+    // break off and free the tail
+    UndoesFree( undo );
+    undoprev->next = 0;
+}
+
+
 void UndoesFree(Undoes *undo) {
     Undoes *unext;
     BDFRefChar *head, *next;
diff --git a/fontforge/metricsview.c b/fontforge/metricsview.c
index 6337c67..fc4b16e 100644
--- a/fontforge/metricsview.c
+++ b/fontforge/metricsview.c
@@ -2774,7 +2774,7 @@ static int PXSZ_OK(GGadget *g, GEvent *e) {
 	dpi = GetInt8( pxsz->gw, CID_DPI, _("DPI"), &err );
 	if ( err )
 return(true);
-	if ( ptsize<3 || ptsize>300 || dpi<10 || dpi > 2000 ) {
+	if ( ptsize<3 || ptsize>1500 || dpi<10 || dpi > 2000 ) {
 	    ff_post_error(_("Number out of range"),_("Number out of range"));
 return( true );
 	}
diff --git a/fontforge/prefs.c b/fontforge/prefs.c
index 4bf7426..95c33cf 100644
--- a/fontforge/prefs.c
+++ b/fontforge/prefs.c
@@ -167,6 +167,8 @@ extern int aa_pixelsize;			/* from anchorsaway.c */
 extern enum cvtools cv_b1_tool, cv_cb1_tool, cv_b2_tool, cv_cb2_tool; /* cvpalettes.c */
 extern int show_kerning_pane_in_class;		/* kernclass.c */
 extern int AutoSaveFrequency;			/* autosave.c */
+extern int UndoRedoLimitToSave; /* sfd.c */
+extern int UndoRedoLimitToLoad; /* sfd.c */
 
 extern NameList *force_names_when_opening;
 extern NameList *force_names_when_saving;
@@ -287,6 +289,7 @@ static struct prefs_list {
 #endif
 	{ N_("ExportClipboard"), pr_bool, &export_clipboard, NULL, NULL, '\0', NULL, 0, N_( "If you are running an X11 clipboard manager you might want\nto turn this off. FF can put things into its internal clipboard\nwhich it cannot export to X11 (things like copying more than\none glyph in the fontview). If you have a clipboard manager\nrunning it will force these to be exported with consequent\nloss of data.") },
 	{ N_("AutoSaveFrequency"), pr_int, &AutoSaveFrequency, NULL, NULL, '\0', NULL, 0, N_( "The number of seconds between autosaves. If you set this to 0 there will be no autosaves.") },
+	{ N_("UndoRedoLimitToSave"), pr_int, &UndoRedoLimitToSave, NULL, NULL, '\0', NULL, 0, N_( "The number of undo and redo operations which will be saved in sfd files.\nIf you set this to 0 undo/redo information is not saved to sfd files.\nIf set to -1 then all available undo/redo information is saved without limit.") },
 	{ NULL }
 },
   new_list[] = {
@@ -302,6 +305,7 @@ static struct prefs_list {
 	{ N_("PreserveTables"), pr_string, &SaveTablesPref, NULL, NULL, 'P', NULL, 0, N_("Enter a list of 4 letter table tags, separated by commas.\nFontForge will make a binary copy of these tables when it\nloads a True/OpenType font, and will output them (unchanged)\nwhen it generates the font. Do not include table tags which\nFontForge thinks it understands.") },
 	{ N_("SeekCharacter"), pr_unicode, &home_char, NULL, NULL, '\0', NULL, 0, N_("When fontforge opens a (non-sfd) font it will try to display this unicode character in the fontview.")},
 	{ N_("CompactOnOpen"), pr_bool, &compact_font_on_open, NULL, NULL, 'O', NULL, 0, N_("When a font is opened, should it be made compact?")},
+	{ N_("UndoRedoLimitToLoad"), pr_int, &UndoRedoLimitToLoad, NULL, NULL, '\0', NULL, 0, N_( "The number of undo and redo operations to load from sfd files.\nWith this option you can disgard undo information while loading SFD files.\nIf set to 0 then no undo/redo information is loaded.\nIf set to -1 then all available undo/redo information is loaded without limit.") },
 	{ NULL }
 },
   navigation_list[] = {
	{ N_("GlyphAutoGoto"), pr_bool, &cv_auto_goto, NULL, NULL, '\0', NULL, 0, N_("Typing a normal character in the glyph view window changes the window to look at that character") },
 	{ N_("OpenCharsInNewWindow"), pr_bool, &OpenCharsInNewWindow, NULL, NULL, '\0', NULL, 0, N_("When double clicking on a character in the font view\nopen that character in a new window, otherwise\nreuse an existing one.") },
 	{ NULL }
 },
@@ -319,7 +323,7 @@ static struct prefs_list {
 	{ N_("JoinSnap"), pr_real, &joinsnap, NULL, NULL, '\0', NULL, 0, N_("The Edit->Join command will join points which are this close together\nA value of 0 means they must be coincident") },
 	{ N_("StopAtJoin"), pr_bool, &stop_at_join, NULL, NULL, '\0', NULL, 0, N_("When dragging points in the outline view a join may occur\n(two open contours may connect at their endpoints). When\nthis is On a join will cause FontForge to stop moving the\nselection (as if the user had released the mouse button).\nThis is handy if your fingers are inclined to wiggle a bit.") },
 	{ N_("CopyMetaData"), pr_bool, &copymetadata, NULL, NULL, '\0', NULL, 0, N_("When copying glyphs from the font view, also copy the\nglyphs' metadata (name, encoding, comment, etc).") },
-	{ N_("UndoDepth"), pr_int, &maxundoes, NULL, NULL, '\0', NULL, 0, N_("The maximum number of Undoes/Redoes stored in a glyph") },
+	{ N_("UndoDepth"), pr_int, &maxundoes, NULL, NULL, '\0', NULL, 0, N_("The maximum number of Undoes/Redoes stored in a glyph. Use -1 for infinite Undoes\n(but watch RAM consumption and use the Edit menu's Remove Undoes as needed)") },
 	{ N_("UpdateFlex"), pr_bool, &updateflex, NULL, NULL, '\0', NULL, 0, N_("Figure out flex hints after every change") },
 	{ N_("AutoKernDialog"), pr_bool, &default_autokern_dlg, NULL, NULL, '\0', NULL, 0, N_("Open AutoKern dialog for new kerning subtables") },
 	{ NULL }
diff --git a/fontforge/sfd.c b/fontforge/sfd.c
index 76fcdb5..dad92ec 100644
--- a/fontforge/sfd.c
+++ b/fontforge/sfd.c
@@ -46,8 +46,15 @@
 # define NAME_MAX _POSIX_NAME_MAX
 #endif
 
+int UndoRedoLimitToSave = 12; 
+int UndoRedoLimitToLoad = 12; 
+
 extern struct compressors compressors[];
 
+static char *joins[] = { "miter", "round", "bevel", "inher", NULL };
+static char *caps[] = { "butt", "round", "square", "inher", NULL };
+static char *spreads[] = { "pad", "reflect", "repeat", NULL };
+
 /* I will retain this list in case there are still some really old sfd files */
 /*  including numeric encodings.  This table maps them to string encodings */
 static const char *charset_names[] = {
@@ -109,6 +116,20 @@ static char base64[64] = {
  'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
  'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
 
+static const char *end_tt_instrs = "EndTTInstrs";
+static void SFDDumpRefs(FILE *sfd,RefChar *refs, char *name,EncMap *map, int *newgids);
+static RefChar *SFDGetRef(FILE *sfd, int was_enc);
+static void SFDDumpImage(FILE *sfd,ImageList *img);
+static AnchorPoint *SFDReadAnchorPoints(FILE *sfd,SplineChar *sc,AnchorPoint** alist, AnchorPoint *lastap);
+static void SFDDumpTtfInstrs(FILE *sfd,SplineChar *sc);
+static void SFDDumpTtfInstrsExplicit(FILE *sfd,SplineChar *sc, uint8 *ttf_instrs, int16 ttf_instrs_len );
+static void SFDDumpHintList(FILE *sfd,char *key, StemInfo *h);
+static void SFDDumpDHintList( FILE *sfd,char *key, DStemInfo *d );
+static StemInfo *SFDReadHints(FILE *sfd);
+static DStemInfo *SFDReadDHints( SplineFont *sf,FILE *sfd,int old );
+extern void ExtractHints(SplineChar *sc,void *hints,int docopy);
+extern void *UHintCopy(SplineChar *sc,int docopy);
+
 static void utf7_encode(FILE *sfd,long ch) {
 
     putc(base64[(ch>>18)&0x3f],sfd);
@@ -699,10 +720,9 @@ return;
 }
 #endif
 
-static void SFDDumpAnchorPoints(FILE *sfd,SplineChar *sc) {
-    AnchorPoint *ap;
-
-    for ( ap = sc->anchor; ap!=NULL; ap=ap->next ) {
+static void SFDDumpAnchorPoints(FILE *sfd,AnchorPoint *ap) {
+    for ( ; ap; ap=ap->next )
+    {
 	fprintf( sfd, "AnchorPoint: " );
 	SFDDumpUTF7Str(sfd,ap->anchor->name);
 	fprintf( sfd, "%g %g %s %d",
@@ -808,6 +828,109 @@ return( NULL );
 return( rle );
 }
 
+static void SFDDumpBrush( FILE *sfd, struct brush* brush ) {
+    fprintf(sfd, "Brush: #%06x %g\n", brush->col, brush->opacity );
+    fprintf(sfd, "EndBrush\n");
+}
+
+static void SFDDumpPen( FILE *sfd, struct pen* p ) {
+    fprintf(sfd, "Pen: %g %s %s [%g %g %g %g] [",
+            p->width, joins[p->linejoin], caps[p->linecap],
+            (double) p->trans[0], (double) p->trans[1],
+            (double) p->trans[2], (double) p->trans[3] );
+    if ( p->dashes[0]==0 && p->dashes[1]==DASH_INHERITED ) {
+	fprintf(sfd,"0 %d]\n", DASH_INHERITED);
+    } else {
+        int j;
+        for ( j=0; j<DASH_MAX && p->dashes[j]!=0; ++j )
+            fprintf( sfd,"%d ", p->dashes[j]);
+        fprintf(sfd,"]\n");
+    }
+    SFDDumpBrush( sfd, &p->brush );
+    fprintf(sfd, "EndPen\n");
+}
+
+
+
+static void SFDDumpUndo(FILE *sfd,SplineChar *sc,Undoes *u, char* keyPrefix, int idx ) {
+    fprintf(sfd, "%sOperation\n",      keyPrefix );
+    fprintf(sfd, "Index: %d\n",        idx );
+    fprintf(sfd, "Type: %d\n",         u->undotype );
+    fprintf(sfd, "WasModified: %d\n",  u->was_modified );
+    fprintf(sfd, "WasOrder2: %d\n",    u->was_order2 );
+
+    switch( u->undotype )
+    {
+        case ut_state:
+            fprintf(sfd, "Width: %d\n",           u->u.state.width );
+            fprintf(sfd, "VWidth: %d\n",          u->u.state.vwidth );
+            fprintf(sfd, "LBearingChange: %d\n",  u->u.state.lbearingchange );
+            fprintf(sfd, "UnicodeEnc: %d\n",      u->u.state.unicodeenc );
+            if( u->u.state.charname )
+                fprintf(sfd, "Charname: \"%s\"\n", u->u.state.charname );
+            if( u->u.state.comment )
+                fprintf(sfd, "Comment: \"%s\"\n", u->u.state.comment );
+            if( u->u.state.refs ) {
+                SFDDumpRefs( sfd, u->u.state.refs, 0, 0, 0 );
+            }
+	    if( u->u.state.images ) {
+                SFDDumpImage( sfd, u->u.state.images );
+            }
+            fprintf(sfd, "InstructionsLength: %d\n", u->u.state.instrs_len );
+            if( u->u.state.anchor ) {
+                SFDDumpAnchorPoints( sfd, u->u.state.anchor );
+            }
+	    if( u->u.state.splines ) {
+                fprintf(sfd, "SplineSet\n", keyPrefix, idx );
+                SFDDumpSplineSet( sfd, u->u.state.splines );
+            }
+            break;
+
+        case ut_statehint:
+        {
+            SplineChar* tsc = 0;
+            tsc = SplineCharCopy( sc, 0, 0 );
+            ExtractHints( tsc, u->u.state.hints, 1 );
+            SFDDumpHintList(  sfd, "HStem: ",  tsc->hstem);
+            SFDDumpHintList(  sfd, "VStem: ",  tsc->vstem);
+            SFDDumpDHintList( sfd, "DStem2: ", tsc->dstem);
+            SplineCharFree( tsc );
+
+	    if( u->u.state.instrs_len )
+                SFDDumpTtfInstrsExplicit( sfd, sc, u->u.state.instrs, u->u.state.instrs_len );
+            break;
+        }
+
+        case ut_hints:
+        {
+            SplineChar* tsc = 0;
+            tsc = SplineCharCopy( sc, 0, 0 );
+            tsc->ttf_instrs = 0;
+            ExtractHints( tsc, u->u.state.hints, 1 );
+            SFDDumpHintList(  sfd, "HStem: ",  tsc->hstem);
+            SFDDumpHintList(  sfd, "VStem: ",  tsc->vstem);
+            SFDDumpDHintList( sfd, "DStem2: ", tsc->dstem);
+            SplineCharFree( tsc );
+
+            if( u->u.state.instrs_len )
+                SFDDumpTtfInstrsExplicit( sfd, sc, u->u.state.instrs, u->u.state.instrs_len );
+            if( u->copied_from && u->copied_from->fullname )
+                fprintf(sfd, "CopiedFrom: %s\n", u->copied_from->fullname );
+            break;
+        }
+        
+        case ut_width:
+        case ut_vwidth:
+        {
+            fprintf(sfd, "Width: %d\n", u->u.width );
+            break;
+        }
+        
+    }
+
+    fprintf(sfd, "End%sOperation\n", keyPrefix );
+}
+
 static void SFDDumpImage(FILE *sfd,ImageList *img) {
     GImage *image = img->image;
     struct _GImage *base = image->list_len==0?image->u.image:image->u.images[0];
@@ -909,10 +1032,9 @@ return;
     }
 }
 
-static const char *end_tt_instrs = "EndTTInstrs";
-static void SFDDumpTtfInstrs(FILE *sfd,SplineChar *sc) {
-#if 1
-    char *instrs = _IVUnParseInstrs( sc->ttf_instrs,sc->ttf_instrs_len );
+static void SFDDumpTtfInstrsExplicit(FILE *sfd,SplineChar *sc, uint8 *ttf_instrs, int16 ttf_instrs_len )
+{
+    char *instrs = _IVUnParseInstrs( ttf_instrs, ttf_instrs_len );
     char *pt;
     fprintf( sfd, "TtInstrs:\n" );
     for ( pt=instrs; *pt!='\0'; ++pt )
@@ -921,19 +1043,10 @@ static void SFDDumpTtfInstrs(FILE *sfd,SplineChar *sc) {
 	putc('\n',sfd);
     free(instrs);
     fprintf( sfd, "%s\n", end_tt_instrs );
-#else
-    struct enc85 enc;
-    int i;
-
-    memset(&enc,'\0',sizeof(enc));
-    enc.sfd = sfd;
-
-    fprintf( sfd, "TtfInstrs: %d\n", sc->ttf_instrs_len );
-    for ( i=0; i<sc->ttf_instrs_len; ++i )
-	SFDEnc85(&enc,sc->ttf_instrs[i]);
-    SFDEnc85EndEnc(&enc);
-    fprintf(sfd,"\nEndTtf\n" );
-#endif
+}
+static void SFDDumpTtfInstrs(FILE *sfd,SplineChar *sc)
+{
+    SFDDumpTtfInstrsExplicit( sfd, sc, sc->ttf_instrs,sc->ttf_instrs_len );
 }
 
 static void SFDDumpTtfTable(FILE *sfd,struct ttf_table *tab,SplineFont *sf) {
@@ -1184,9 +1297,6 @@ return( PyFF_UnPickleMeToObjects(buf));
 }
 
 #ifdef FONTFORGE_CONFIG_TYPE3
-static char *joins[] = { "miter", "round", "bevel", "inher", NULL };
-static char *caps[] = { "butt", "round", "square", "inher", NULL };
-static char *spreads[] = { "pad", "reflect", "repeat", NULL };
 
 static void SFDDumpGradient(FILE *sfd, char *keyword, struct gradient *gradient) {
     int i;
@@ -1216,7 +1326,7 @@ static void SFDDumpPattern(FILE *sfd, char *keyword, struct pattern *pattern) {
 }
 #endif
 
-static void SFDDumpChar(FILE *sfd,SplineChar *sc,EncMap *map,int *newgids) {
+static void SFDDumpChar(FILE *sfd,SplineChar *sc,EncMap *map,int *newgids,int saveUndoes) {
     ImageList *img;
     KernPair *kp;
     PST *pst;
@@ -1294,9 +1404,47 @@ static void SFDDumpChar(FILE *sfd,SplineChar *sc,EncMap *map,int *newgids) {
     }
     if ( sc->ttf_instrs_len!=0 )
 	SFDDumpTtfInstrs(sfd,sc);
-    SFDDumpAnchorPoints(sfd,sc);
+    SFDDumpAnchorPoints(sfd,sc->anchor);
     fprintf( sfd, "LayerCount: %d\n", sc->layer_cnt );
     for ( i=0; i<sc->layer_cnt; ++i ) {
+        if( saveUndoes ) {
+            if( sc->layers[i].undoes || sc->layers[i].redoes ) {
+                fprintf(sfd, "UndoRedoHistory\n" );
+                fprintf(sfd, "Layer: %d\n", i );
+                int idx = 0;
+                Undoes *undo = 0;
+                int limit = 0;
+
+                fprintf(sfd, "Undoes\n" );
+                idx = 0;
+                undo = sc->layers[i].undoes;
+                for( limit = UndoRedoLimitToSave;
+                     undo && (limit==-1 || limit>0);
+                     undo = undo->next, idx++ )
+                {
+                    SFDDumpUndo( sfd, sc, undo, "Undo", idx );
+                    if( limit > 0 )
+                        limit--;
+                }
+                fprintf(sfd, "EndUndoes\n" );
+
+		fprintf(sfd, "Redoes\n" );
+                idx = 0;
+                limit = UndoRedoLimitToSave;
+                undo = sc->layers[i].redoes;
+                for( limit = UndoRedoLimitToSave;
+                     undo && (limit==-1 || limit>0);
+                     undo = undo->next, idx++ )
+                {
+                    SFDDumpUndo( sfd, sc, undo, "Redo", idx );
+                    if( limit > 0 )
+                        limit--;
+                }
+                fprintf(sfd, "EndRedoes\n" );
+                fprintf(sfd, "EndUndoRedoHistory\n" );
+            }
+        }
+        
 #ifdef FONTFORGE_CONFIG_TYPE3
 	if ( sc->parent->multilayer ) {
 	    fprintf(sfd, "Layer: %d  %d %d %d  #%06x %g  #%06x %g %g %s %s [%g %g %g %g] [",
@@ -2360,14 +2508,14 @@ static int SFD_Dump(FILE *sfd,SplineFont *sf,EncMap *map,EncMap *normal,
 	for ( i=0; i<sf->glyphcnt; ++i ) {
 	    if ( !SFDOmit(sf->glyphs[i]) ) {
 		if ( !todir )
-		    SFDDumpChar(sfd,sf->glyphs[i],map,newgids);
+		    SFDDumpChar(sfd,sf->glyphs[i],map,newgids,1 );
 		else {
 		    char *glyphfile = galloc(strlen(dirname)+2*strlen(sf->glyphs[i]->name)+20);
 		    FILE *gsfd;
 		    appendnames(glyphfile,dirname,"/",sf->glyphs[i]->name,GLYPH_EXT );
 		    gsfd = fopen(glyphfile,"w");
 		    if ( gsfd!=NULL ) {
-			SFDDumpChar(gsfd,sf->glyphs[i],map,newgids);
+			SFDDumpChar(gsfd,sf->glyphs[i],map,newgids,1 );
 			if ( ferror(gsfd)) err = true;
 			if ( fclose(gsfd)) err = true;
 		    } else
@@ -2522,7 +2670,10 @@ static int SFDDump(FILE *sfd,SplineFont *sf,EncMap *map,EncMap *normal,
     ff_progress_start_indicator(10,_("Saving..."),_("Saving Spline Font Database"),_("Saving Outlines"),
 	    realcnt,i+1);
     ff_progress_enable_stop(false);
-    fprintf(sfd, "SplineFontDB: %.1f\n", 3.0 );
+    double version = 3.1;
+    if( !UndoRedoLimitToSave )
+        version = 3.0;
+    fprintf(sfd, "SplineFontDB: %.1f\n", version );
     if ( sf->mm != NULL )
 	err = SFD_MMDump(sfd,sf->mm->normal,map,normal,todir,dirname);
     else
@@ -3510,6 +3661,150 @@ static SplineSet *SFDGetSplineSet(SplineFont *sf,FILE *sfd,int order2) {
 return( head );
 }
 
+static Undoes *SFDGetUndo( SplineFont *sf, FILE *sfd, SplineChar *sc,
+                           const char* startTag, const char* endTag, int current_layer )
+{
+    Undoes *u = 0;
+    char tok[2000], ch;
+    int i;
+    RefChar *lastr=NULL;
+    ImageList *lasti=NULL;
+    AnchorPoint *lastap = NULL;
+    SplineChar* tsc = 0;
+    int haveReadAHint = 0;
+    
+    if ( getname(sfd,tok)!=1 )
+        return( NULL );
+    if ( strcmp(tok, startTag) )
+        return( NULL );
+
+    u = chunkalloc(sizeof(Undoes));
+    u->undotype = ut_state;
+
+    while ( 1 )
+    {
+        if ( getname(sfd,tok)!=1 ) {
+            chunkfree(u,sizeof(Undoes));
+            return( NULL );
+        }
+	
+        if ( !strmatch(tok,"EndUndoOperation")
+            || !strmatch(tok,"EndRedoOperation"))
+        {
+            if( u->undotype == ut_hints ) {
+                if( tsc ) {
+                    u->u.state.hints = UHintCopy(tsc,1);
+                    SplineCharFree( tsc );
+                }
+            }
+            
+            return u;
+        }
+	if ( !strmatch(tok,"Index:")) {
+            getint(sfd,&i);
+        }
+	if ( !strmatch(tok,"Type:")) {
+            getint(sfd,&i);
+            u->undotype = i;
+            if( u->undotype == ut_hints ) {
+                tsc = SplineCharCopy( sc, 0, 0 );
+                tsc->hstem = 0;
+                tsc->vstem = 0;
+                tsc->dstem = 0;
+            }
+        }
+        if ( !strmatch(tok,"WasModified:")) {
+            getint(sfd,&i);
+            u->was_modified = i;
+        }
+        if ( !strmatch(tok,"WasOrder2:")) {
+            getint(sfd,&i);
+            u->was_order2 = i;
+        }
+
+        switch( u->undotype )
+        {
+	 case ut_state:
+	    if ( !strmatch(tok,"Width:"))          { getint(sfd,&i); u->u.state.width = i; }
+	    if ( !strmatch(tok,"VWidth:"))         { getint(sfd,&i); u->u.state.vwidth = i; }
+	    if ( !strmatch(tok,"LBearingChange:")) { getint(sfd,&i); u->u.state.lbearingchange = i; }
+	    if ( !strmatch(tok,"UnicodeEnc:"))     { getint(sfd,&i); u->u.state.unicodeenc = i; }
+	    if ( !strmatch(tok,"Charname:"))       { u->u.state.charname = getquotedeol(sfd); }
+	    if ( !strmatch(tok,"Comment:"))        { u->u.state.comment  = getquotedeol(sfd); }
+	    
+	    if( !strmatch(tok,"Refer:"))
+	    {
+		RefChar *ref = SFDGetRef(sfd,strmatch(tok,"Ref:")==0);
+		if ( !u->u.state.refs )
+		    u->u.state.refs = ref;
+		else
+		    lastr->next = ref;
+		lastr = ref;
+	    }
+	    
+	    if( !strmatch(tok,"Image:"))
+	    {
+		int ly = current_layer;
+		ImageList *img = SFDGetImage(sfd);
+		if ( !u->u.state.images )
+		    u->u.state.images = img;
+		else
+		    lasti->next = img;
+		lasti = img;
+	    }
+	    
+	    if( !strmatch(tok,"Comment:")) {
+		u->u.state.comment  = getquotedeol(sfd);
+	    }
+	    if( !strmatch(tok,"InstructionsLength:")) {
+		getint(sfd,&i); u->u.state.instrs_len = i;
+	    }
+	    if( !strmatch(tok,"AnchorPoint:") ) {
+		lastap = SFDReadAnchorPoints( sfd, sc, &(u->u.state.anchor), lastap );
+	    }
+	    if ( !strmatch(tok,"SplineSet")) {
+		u->u.state.splines = SFDGetSplineSet(sf,sfd,sc->layers[current_layer].order2);
+	    }
+	    break;
+
+	case ut_hints:
+	{
+	    if ( !strmatch(tok,"HStem:") ) {
+		tsc->hstem = SFDReadHints(sfd);
+		tsc->hconflicts = StemListAnyConflicts(tsc->hstem);
+		haveReadAHint = 1;
+	    }
+	    else if ( !strmatch(tok,"VStem:") ) {
+		tsc->vstem = SFDReadHints(sfd);
+		tsc->vconflicts = StemListAnyConflicts(tsc->vstem);
+		haveReadAHint = 1;
+	    }
+	    else if( !strmatch(tok,"DStem2:")) {
+		tsc->dstem = SFDReadDHints( sc->parent,sfd,false );
+		haveReadAHint = 1;
+	    }
+	    else if( !strmatch(tok,"TtInstrs:")) {
+		SFDGetTtInstrs(sfd,tsc);
+		u->u.state.instrs = tsc->ttf_instrs;
+		u->u.state.instrs_len = tsc->ttf_instrs_len;
+		tsc->ttf_instrs = 0;
+		tsc->ttf_instrs_len = 0;
+	    }
+	    break;
+	}
+            
+	case ut_width:
+	case ut_vwidth:
+	    if( !strmatch(tok,"Width:")) {
+		getint(sfd,&i); u->u.width = i;
+	    }
+	    break;
+        }
+    }
+
+    return u;
+}
+
 static void SFDGetMinimumDistances(FILE *sfd, SplineChar *sc) {
     SplineSet *ss;
     SplinePoint *sp;
@@ -3803,7 +4098,8 @@ static void SFDSkipValDevTab(FILE *sfd) {
 }
 #endif
 
-static AnchorPoint *SFDReadAnchorPoints(FILE *sfd,SplineChar *sc,AnchorPoint *lastap) {
+static AnchorPoint *SFDReadAnchorPoints(FILE *sfd,SplineChar *sc,AnchorPoint** alist, AnchorPoint *lastap)
+{
     AnchorPoint *ap = chunkalloc(sizeof(AnchorPoint));
     AnchorClass *an;
     char *name;
@@ -3859,10 +4155,11 @@ return( lastap );
 return( lastap );
     }
     if ( lastap==NULL )
-	sc->anchor = ap;
+	(*alist) = ap;
     else
 	lastap->next = ap;
-return( ap );
+    
+    return( ap );
 }
 
 static RefChar *SFDGetRef(FILE *sfd, int was_enc) {
@@ -4129,6 +4426,23 @@ return( pat );
 }
 #endif
 
+
+static void SFDConsumeUntil( FILE *sfd, char** terminators ) {
+    char tok[2000];
+    int i;
+    int ch;
+
+    char* line = 0;
+    while( line = getquotedeol( sfd )) {
+        char** tp = terminators;
+        for( ; tp && *tp; ++tp ) {
+            if( !strnmatch( line, *tp, strlen( *tp ))) {
+                return;
+            }
+        }
+    }
+}
+
 static int orig_pos;
 
 static SplineChar *SFDGetChar(FILE *sfd,SplineFont *sf, int had_sf_layer_cnt) {
@@ -4362,7 +4676,7 @@ return( NULL );
 		SFDGetHintMask(sfd,&sc->countermasks[i]);
 	    }
 	} else if ( strmatch(tok,"AnchorPoint:")==0 ) {
-	    lastap = SFDReadAnchorPoints(sfd,sc,lastap);
+	    lastap = SFDReadAnchorPoints(sfd,sc,&sc->anchor,lastap);
 	} else if ( strmatch(tok,"Fore")==0 ) {
 	    while ( isspace(ch = nlgetc(sfd)));
 	    ungetc(ch,sfd);
@@ -4477,6 +4791,68 @@ return( NULL );
 	} else if ( strmatch(tok,"StrokePattern:")==0 ) {
 	    sc->layers[current_layer].stroke_pen.brush.pattern = SFDParsePattern(sfd,tok);
 #endif
+	} else if ( strmatch(tok,"UndoRedoHistory")==0 ) {
+
+	    getname(sfd,tok);
+	    if ( !strmatch(tok,"Layer:") ) {
+		int layer;
+		getint(sfd,&layer);
+	    }
+
+	    int limit;
+	    Undoes *undo = 0;
+	    struct undoes *last = 0;
+            
+	    getname(sfd,tok);
+	    if ( !strmatch(tok,"Undoes") ) {
+		undo = 0;
+		limit = UndoRedoLimitToLoad;
+		last = sc->layers[current_layer].undoes;
+		while( undo = SFDGetUndo( sf, sfd, sc, "UndoOperation", "EndUndoOperation", current_layer ) ) 
+		{
+		    // push to back
+		    if( last ) last->next = undo;
+		    else       sc->layers[current_layer].undoes = undo;
+		    last = undo;
+		    
+		    if( limit != -1 ) {
+			limit--;
+			if( limit <= 0 ) {
+			    // we have hit our load limit, so lets just chuck everything away
+			    // until we hit the EndUndoes/EndRedoes magic line and then start
+			    // actually processing again.
+			    char* terminators[] = { "EndUndoes", "EndRedoes", 0 };
+			    SFDConsumeUntil( sfd, terminators );
+			}
+		    }
+		}
+	    }
+            
+	    getname(sfd,tok);
+	    if ( !strmatch(tok,"Redoes") ) {
+		undo = 0;
+		limit = UndoRedoLimitToLoad;
+		last = sc->layers[current_layer].redoes;
+		while( undo = SFDGetUndo( sf, sfd, sc, "RedoOperation", "EndRedoOperation", current_layer ) ) 
+		{
+		    // push to back
+		    if( last ) last->next = undo;
+		    else       sc->layers[current_layer].redoes = undo;
+		    last = undo;
+		    
+		    if( limit != -1 ) {
+			limit--;
+			if( limit <= 0 ) {
+			    // we have hit our load limit, so lets just chuck everything away
+			    // until we hit the EndUndoes/EndRedoes magic line and then start
+			    // actually processing again.
+			    char* terminators[] = { "EndUndoes", "EndRedoes", 0 };
+			    SFDConsumeUntil( sfd, terminators );
+			}
+		    }
+		}
+	    }
+
 	} else if ( strmatch(tok,"SplineSet")==0 ) {
 	    sc->layers[current_layer].splines = SFDGetSplineSet(sf,sfd,sc->layers[current_layer].order2);
 	} else if ( strmatch(tok,"Ref:")==0 || strmatch(tok,"Refer:")==0 ) {
@@ -7315,8 +7693,12 @@ return( -1 );
     /*  this sequence, but I don't yet generate it. I want the parser to */
     /*  perculate through to users before I introduce the new format so there */
     /*  will be fewer complaints when it happens */
-    if ( dval!=0 && dval!=1 && dval!=2.0 && dval!=3.0 && dval!=4.0 ) {
-	LogError("Bad SFD Version number %.1f", dval );
+    // MIQ: getreal() can give some funky rounding errors it seems
+    if ( dval!=0 && dval!=1 && dval!=2.0 && dval!=3.0
+         && !(dval > 3.09 && dval <= 3.11)
+         && dval!=4.0 )
+    {
+        LogError("Bad SFD Version number %.1f", dval );
 return( -1 );
     }
     ch = nlgetc(sfd); ungetc(ch,sfd);
@@ -7741,7 +8123,7 @@ return;
 	    }
 	}
 	if ( ssf->glyphs[i]!=NULL && ssf->glyphs[i]->changed )
-	    SFDDumpChar( asfd,ssf->glyphs[i],map,NULL);
+	    SFDDumpChar( asfd,ssf->glyphs[i],map,NULL,1);
     }
     fprintf( asfd, "EndChars\n" );
     fprintf( asfd, "EndSplineFont\n" );
diff --git a/fontforge/splinefont.c b/fontforge/splinefont.c
index 195c306..872a5e0 100644
--- a/fontforge/splinefont.c
+++ b/fontforge/splinefont.c
@@ -1993,3 +1993,22 @@ void SFLayerSetBackground(SplineFont *sf,int layer,int is_back) {
 	++k;
     } while ( k<sf->subfontcnt );
 }
+
+#include <stddef.h>
+
+int listLength( void* p, int nextoffset ) {
+    if( !p )
+        return 0;
+    int ret = 1;
+    p = *((void**)(p + nextoffset));
+    for( ; p; ret++ ) {
+        p = *((void**)(p + nextoffset));
+    }
+    return ret;
+}
+
+int undoesLength( struct undoes *undoes ) {
+    int offset = offsetof( Undoes, next );
+    return listLength( undoes, offset );
+}
+
diff --git a/fontforge/splinefont.h b/fontforge/splinefont.h
index 97abe23..f575e5f 100644
--- a/fontforge/splinefont.h
+++ b/fontforge/splinefont.h
@@ -3234,4 +3234,8 @@ extern bigreal SFDescender(SplineFont *sf, int layer, int return_error);
 
 extern SplineChar ***GlyphClassesFromNames(SplineFont *sf,char **classnames,
 	int class_cnt );
+
+extern int listLength( void* head, int nextoffset );
+extern int undoesLength( struct undoes *undoes );
+
 #endif
diff --git a/fonttools/sfd-version-convert.pl b/fonttools/sfd-version-convert.pl
new file mode 100755
index 0000000..d322448
--- /dev/null
+++ b/fonttools/sfd-version-convert.pl
@@ -0,0 +1,73 @@
+#!/usr/bin/perl
+
+use Getopt::Long;
+use Pod::Usage;
+
+my $outversion = 0;
+
+GetOptions ("outputversion=f" => \$outversion ) or pod2usage(2);
+if( $outversion == 0 ) 
+{
+    pod2usage(1);
+    die;
+}
+
+$ifilename = shift;
+if( $ifilename eq "" ) { $ifilename = "-"; }
+#print $ifilename;
+
+$ignore = 0;
+$endtok = "";
+open INFILE, $ifilename or die "Can't open input file $ifilename";
+while( <INFILE> ) 
+{
+    if( /^SplineFontDB/ ) {
+	print "SplineFontDB: " . $outversion . "\n";
+	next;
+    }
+    if( /^UndoRedoHistory/ ) {
+	$ignore = 1;
+	$endtok = "^EndUndoRedoHistory";
+    }
+    if( $endtok ne "" && /$endtok/ ) {
+	$ignore = 0;
+	next;
+    }
+
+    if( $ignore == 0 ) 
+    {
+	$line = $_;
+	print $line;
+    }
+}
+
+__END__
+
+=head1 NAME
+
+    sfd-version-convert.pl - Convert an SFD file to an older version if possible
+ 
+=head1 SYNOPSIS
+
+    sfd-version-convert.pl [options] [file ...]
+
+     Options:
+       -outputversion N.N  :  which version of SFD to create
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<-outputversion>
+
+    Which version you would like to create (currently only 3.0 supported).
+    Reading a version 3.1 SFD file to a version 3.0 will:
+    * Remove blocks that contain undo information.
+
+=back
+
+=head1 DESCRIPTION
+
+    B<This program> will try to convert an SFD file to a specific older version
+
+=cut
diff --git a/gtkui/prefs.c b/gtkui/prefs.c
index b49ee83..42e86e4 100644
--- a/gtkui/prefs.c
+++ b/gtkui/prefs.c
@@ -258,7 +258,7 @@ static struct prefs_list {
 	{ N_("JoinSnap"), pr_real, &joinsnap, NULL, NULL, '\0', NULL, 0, N_("The Edit->Join command will join points which are this close together\nA value of 0 means they must be coincident") },
 	{ N_("StopAtJoin"), pr_bool, &stop_at_join, NULL, NULL, '\0', NULL, 0, N_("When dragging points in the outline view a join may occur\n(two open contours may connect at their endpoints). When\nthis is On a join will cause FontForge to stop moving the\nselection (as if the user had released the mouse button).\nThis is handy if your fingers are inclined to wiggle a bit.") },
 	{ N_("CopyMetaData"), pr_bool, &copymetadata, NULL, NULL, '\0', NULL, 0, N_("When copying glyphs from the font view, also copy the\nglyphs' metadata (name, encoding, comment, etc).") },
-	{ N_("UndoDepth"), pr_int, &maxundoes, NULL, NULL, '\0', NULL, 0, N_("The maximum number of Undoes/Redoes stored in a glyph") },
+	{ N_("UndoDepth"), pr_int, &maxundoes, NULL, NULL, '\0', NULL, 0, N_("The maximum number of Undoes/Redoes stored in a glyph. Use -1 for infinite Undoes\n(but watch RAM consumption and use the Edit menu's Remove Undoes as needed)") },
 	{ N_("UpdateFlex"), pr_bool, &updateflex, NULL, NULL, '\0', NULL, 0, N_("Figure out flex hints after every change") },
 	{ NULL }
 },
